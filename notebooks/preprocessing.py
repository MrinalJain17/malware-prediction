import pandas as pd
import numpy as np
from category_encoders.binary import BinaryEncoder

import dataset

data = dataset.load_data("./microsoft-malware-prediction/train.feather")

drop_columns = [
    "ProductName",
    "IsBeta",
    "RtpStateBitfield",
    "IsSxsPassiveMode",
    "AVProductsEnabled",
    "HasTpm",
    "Platform",
    "OsVer",
    "AutoSampleOptIn",
    "SMode",
    "Firewall",
    "UacLuaenable",
    "Census_DeviceFamily",
    "Census_IsPortableOperatingSystem",
    "Census_IsFlightsDisabled",
    "Census_IsVirtualDevice",
    "Census_IsPenCapable",
    "DefaultBrowsersIdentifier",
    "PuaMode",
    "Census_ProcessorClass",
    "Census_InternalBatteryType",
    "Census_IsFlightingInternal",
    "Census_ThresholdOptIn",
    "Census_IsWIMBootEnabled",
]

data.drop(columns=drop_columns, inplace=True)

data["Census_PrimaryDiskTotalCapacity"] = np.around(
    data["Census_PrimaryDiskTotalCapacity"] / 1024, decimals=0
)
data["Census_SystemVolumeTotalCapacity"] = np.around(
    data["Census_SystemVolumeTotalCapacity"] / 1024, decimals=0
)
data["Census_TotalPhysicalRAM"] = np.around(
    data["Census_TotalPhysicalRAM"] / 1024, decimals=0
)

data["aspect_ratio"] = (
    data["Census_InternalPrimaryDisplayResolutionHorizontal"]
    / data["Census_InternalPrimaryDisplayResolutionVertical"]
)
data.drop(
    columns=[
        "Census_InternalPrimaryDisplayResolutionHorizontal",
        "Census_InternalPrimaryDisplayResolutionVertical",
    ],
    inplace=True,
)

numerical_columns = data.select_dtypes(exclude="category").columns.tolist()

bins_map = {
    "Census_ProcessorCoreCount": {
        "bins": [0, 2, 4, 8, 16, 32, 64, 128, 2048],
        "labels": [
            "<= 2",
            "2 - 4",
            "4 - 8",
            "8 - 16",
            "16 - 32",
            "32 - 64",
            "64 - 128",
            "> 128",
        ],
    },
    "Census_PrimaryDiskTotalCapacity": {
        "bins": [0, 250, 500, 750, 1000, 10 ** 10],
        "labels": [
            "<= 250 GB",
            "250 - 500 GB",
            "500 - 750 GB",
            "750 - 1000 GB",
            "> 1000 GB",
        ],
    },
    "Census_SystemVolumeTotalCapacity": {
        "bins": [0, 250, 500, 750, 1000, 10 ** 5],
        "labels": [
            "<= 250 GB",
            "250 - 500 GB",
            "500 - 750 GB",
            "750 - 1000 GB",
            "> 1000 GB",
        ],
    },
    "Census_TotalPhysicalRAM": {
        "bins": [0, 2, 4, 6, 8, 16, 32, 2048],
        "labels": [
            "<= 2GB",
            "2 - 4 GB",
            "4 - 6 GB",
            "6 - 8 GB",
            "8 - 16 GB",
            "16 - 32 GB",
            "> 32 GB",
        ],
    },
    "Census_InternalBatteryNumberOfCharges": {
        "bins": [-1, 10 ** 3, 10 ** 6, 10 ** 10],
        "labels": ["<= 1K", "1K - 1M", "> 1M"],
    },
    "Census_InternalPrimaryDiagonalDisplaySizeInInches": {
        "bins": [0, 10, 20, 30, 200],
        "labels": ["<= 10", "10 - 20", "20 - 30", "> 30"],
    },
    "aspect_ratio": {
        "bins": [0, 1, 1.5, 2, 20],
        "labels": ["<= 1", "1 - 1.5", "1.5 - 2", "> 2"],
    },
}

# Converting numerical columns to categorical based on the provided bin configuration
for col in numerical_columns:
    data[col] = pd.cut(
        data[col], bins=bins_map[col]["bins"], labels=bins_map[col]["labels"]
    )
    data[col].cat.set_categories(data[col].cat.categories, ordered=False, inplace=True)

# Representing NaN as an individual category in all the columns
columns = data.columns
for col in columns:
    if data[col].isna().sum() > 0:
        data[col].cat.add_categories("NA", inplace=True)
        data[col].fillna("NA", inplace=True)

summary = data.describe().T
columns_one_hot = summary[summary["unique"] <= 15].index.tolist()
columns_binary = summary[summary["unique"] > 15].index.tolist()
columns_one_hot.remove("HasDetections")

data = pd.get_dummies(data, columns=columns_one_hot)

binary_encoder = BinaryEncoder(cols=columns_binary, return_df=True)
data = binary_encoder.fit_transform(data)
added_cols = data.select_dtypes(include=["int64"]).columns.tolist()
data[added_cols] = data[added_cols].astype("uint8")

dataset.save_as_feather(
    data, filename="./microsoft-malware-prediction/processed/train_preprocessed"
)
